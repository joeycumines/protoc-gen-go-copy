// Copyright 2021 Joseph Cumines
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Command protoc-gen-go-copy is a protoc plugin that generates code to copy messages without reflection.
package main

import (
	"flag"
	"fmt"
	"github.com/jhump/gopoet"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"io"
	"os"
	"path"
	"sync"
)

func main() {
	config := DefaultGenerator
	(protogen.Options{ParamFunc: config.NewFlagSet().Set}).Run(func(gen *protogen.Plugin) error {
		config.Plugin = gen
		return config.Generate()
	})
}

var DefaultGenerator = Generator{
	Cache:                   new(goCache),
	Write:                   defaultWriter,
	GeneratedFilenameSuffix: "_copy.pb.go",
	ShallowCopyMethod:       "ShallowCopy",
	ShallowCloneMethod:      "ShallowClone",
}

type (
	Generator struct {
		Plugin                  *protogen.Plugin
		Cache                   Cache
		Write                   Writer
		GeneratedFilenameSuffix string
		ShallowCopyMethod       string
		ShallowCloneMethod      string
	}

	// Writer writes to or deletes a generated file, where a nil reader is used to indicate delete, which is used to
	// handle existing files that are no longer necessary
	Writer func(filename string, reader io.Reader) error
)

func defaultWriter(filename string, reader io.Reader) error {
	if reader == nil {
		if err := os.Remove(filename); err != nil && !os.IsNotExist(err) {
			return err
		}
		return nil
	}
	writer, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer writer.Close()
	if _, err := io.Copy(writer, reader); err != nil {
		return err
	}
	return writer.Close()
}

func (x *Generator) NewFlagSet() *flag.FlagSet {
	var (
		flags   flag.FlagSet
		addFlag = func(v *string, n string) { flags.StringVar(v, n, *v, "method name generated for all message types unless set to an empty string") }
	)
	addFlag(&x.GeneratedFilenameSuffix, "generated_filename_suffix")
	addFlag(&x.ShallowCopyMethod, "shallow_copy_method")
	addFlag(&x.ShallowCloneMethod, "shallow_clone_method")
	return &flags
}

func (x Generator) Generate() error {
	for _, file := range x.Plugin.Files {
		x.Cache.AddFile(file)

		if !file.Generate {
			continue
		}

		filename := file.GeneratedFilenamePrefix + x.GeneratedFilenameSuffix

		f := gopoet.NewGoFile(path.Base(filename), string(file.GoImportPath), string(file.GoPackageName))
		f.FileComment = fmt.Sprintf("Code generated by protoc-gen-go-copy. DO NOT EDIT.\nsource: %s", file.Desc.Path())

		var (
			write  bool
			genMsg func(msg *protogen.Message)
		)
		genMsg = func(msg *protogen.Message) {
			if msg.Desc.IsMapEntry() {
				return
			}

			var (
				t      = x.Cache.MessageType(msg.Desc)
				fields = x.Cache.MessageFields(msg)
			)

			if x.ShallowCopyMethod != `` {
				write = true
				elem := gopoet.NewMethod(gopoet.NewPointerReceiverForType(`x`, t), x.ShallowCopyMethod)
				elem.SetComment(fmt.Sprintf(`%s copies fields, from v to the receiver, using field getters.
Note that v is of an arbitrary type, which may implement any number of the
field getters, which are defined as any methods of the same signature as those
generated for the receiver type, with a name starting with Get.`, x.ShallowCopyMethod))
				elem.AddArg(`v`, gopoet.InterfaceType(nil))
				if len(fields) != 0 {
					elem.Printlnf(`switch v := v.(type) {`)
					elem.Printlnf(`case %s:`, gopoet.PointerType(t))
					for _, field := range fields {
						elem.Printlnf(`x.%s = v.%s()`, field.Name(), field.Getter().Name)
					}
					elem.Println(`default:`)
					for _, field := range fields {
						elem.Printlnf(`if v, ok := v.(%s); ok {`, gopoet.InterfaceType(nil, field.Getter()))
						elem.Printlnf(`x.%s = v.%s()`, field.Name(), field.Getter().Name)
						if field.OneOf() != nil {
							elem.Println(`} else {`)
							elem.Println(`func() {`)
							for _, oneOfField := range field.OneOfFields() {
								elem.Printlnf(`if v, ok := v.(%s); ok {`, gopoet.InterfaceType(nil, oneOfField.Getter))
								elem.Printlnf(`if v := v.%s(); v != nil {`, oneOfField.Getter.Name)
								elem.Printlnf(`x.%s = &%s{%s: v}`, field.Name(), oneOfField.Type, oneOfField.Field.GoName)
								elem.Println(`return`)
								elem.Println(`}`)
								elem.Println(`}`)
							}
							elem.Println(`}()`)
						}
						elem.Println(`}`)
					}
					elem.Println(`}`)
				}
				f.AddElement(elem)
			}

			if x.ShallowCloneMethod != `` {
				write = true
				elem := gopoet.NewMethod(gopoet.NewPointerReceiverForType(`x`, t), x.ShallowCloneMethod)
				elem.SetComment(fmt.Sprintf(`%s returns a shallow copy of the receiver or nil if it's nil.`, x.ShallowCloneMethod))
				elem.AddResult(`c`, gopoet.PointerType(t))
				elem.Println(`if x != nil {`)
				elem.Printlnf(`c = new(%s)`, t)
				for _, field := range fields {
					elem.Printlnf(`c.%s = x.%s`, field.Name(), field.Name())
				}
				elem.Println(`}`)
				elem.Println(`return`)
				f.AddElement(elem)
			}

			for _, msg := range msg.Messages {
				genMsg(msg)
			}
		}
		for _, msg := range file.Messages {
			genMsg(msg)
		}

		if err := func() error {
			var reader io.Reader
			if write {
				r, w := io.Pipe()
				defer r.Close()
				go func() {
					err := gopoet.WriteGoFile(w, f)
					if err != nil {
						switch e := err.(type) {
						case *gopoet.FormatError:
							err = fmt.Errorf("%s: error in generated Go code: %w:\n%s", file.Desc.Path(), e, e.Unformatted)
						default:
							err = fmt.Errorf("%s: %w", file.Desc.Path(), e)
						}
					}
					_ = w.CloseWithError(err)
				}()
				reader = r
			}
			return x.Write(filename, reader)
		}(); err != nil {
			return err
		}
	}

	return nil
}

type (
	Cache interface {
		AddFile(*protogen.File)
		MessageType(protoreflect.MessageDescriptor) gopoet.TypeName
		MessageFields(*protogen.Message) []Field
	}
	Field interface {
		Name() string
		OneOf() *protogen.Oneof
		Fields() []*protogen.Field
		Type() gopoet.TypeName
		Getter() gopoet.MethodType
		OneOfFields() []OneOfField
	}
	OneOfField struct {
		Field  *protogen.Field
		Type   gopoet.TypeName
		Getter gopoet.MethodType
	}
	goCache struct {
		data map[protoreflect.FullName]protogen.GoIdent
		once sync.Once
	}
	goField struct {
		cache       *goCache
		name        string
		oneOf       *protogen.Oneof
		fields      []*protogen.Field
		once        sync.Once
		typeName    gopoet.TypeName
		getter      gopoet.MethodType
		oneOfFields []OneOfField
	}
)

var (
	_ Cache = (*goCache)(nil)
	_ Field = (*goField)(nil)
)

var (
	bytesType = gopoet.SliceType(gopoet.ByteType)
)

func (x *goCache) init() {
	x.data = make(map[protoreflect.FullName]protogen.GoIdent)
}
func (x *goCache) AddFile(v *protogen.File) {
	x.once.Do(x.init)
	for _, v := range v.Enums {
		x.addEnum(v)
	}
	for _, v := range v.Messages {
		x.addMessage(v)
	}
}
func (x *goCache) addEnum(v *protogen.Enum) {
	x.once.Do(x.init)
	x.data[v.Desc.FullName()] = v.GoIdent
	for _, v := range v.Values {
		x.data[v.Desc.FullName()] = v.GoIdent
	}
}
func (x *goCache) addMessage(v *protogen.Message) {
	x.once.Do(x.init)
	x.data[v.Desc.FullName()] = v.GoIdent
	for _, v := range v.Enums {
		x.addEnum(v)
	}
	for _, v := range v.Messages {
		x.addMessage(v)
	}
}
func (x *goCache) MessageType(v protoreflect.MessageDescriptor) gopoet.TypeName {
	x.once.Do(x.init)
	if v != nil {
		if v := x.lookup(v.FullName()); v != nil {
			return v
		}
	}
	panic(fmt.Sprintf("unknown type: %v", v))
}
func (x *goCache) enumType(v protoreflect.EnumDescriptor) gopoet.TypeName {
	x.once.Do(x.init)
	if v != nil {
		if v := x.lookup(v.FullName()); v != nil {
			return v
		}
	}
	panic(fmt.Sprintf("unknown type: %v", v))
}
func (x *goCache) MessageFields(v *protogen.Message) []Field {
	x.once.Do(x.init)
	var (
		fields []Field
		seen   = make(map[string]*goField)
	)
	for _, field := range v.Fields {
		var name string
		if field.Oneof != nil {
			name = field.Oneof.GoName
		} else {
			name = field.GoName
		}
		v := seen[name]
		if v == nil {
			v = &goField{cache: x, name: name, oneOf: field.Oneof}
			fields = append(fields, v)
			seen[name] = v
		}
		if v.oneOf != field.Oneof {
			panic(field)
		}
		v.fields = append(v.fields, field)
	}
	return fields
}
func (x *goCache) lookup(fullName protoreflect.FullName) gopoet.TypeName {
	if ident := x.data[fullName]; ident != (protogen.GoIdent{}) {
		return gopoet.NamedType(gopoet.NewPackage(string(ident.GoImportPath)).Symbol(ident.GoName))
	}
	return nil
}
func (x *goCache) fieldType(v protoreflect.FieldDescriptor) (t gopoet.TypeName) {
	// https://github.com/jhump/goprotoc/blob/70c8197ef4ea66d11022326b63050f6fa10f6b29/plugins/names.go#L337
	x.once.Do(x.init)
	if v.IsMap() {
		return gopoet.MapType(x.fieldType(v.MapKey()), x.fieldType(v.MapValue()))
	}
	switch descriptorpb.FieldDescriptorProto_Type(v.Kind()) {
	case descriptorpb.FieldDescriptorProto_TYPE_BOOL:
		t = gopoet.BoolType
	case descriptorpb.FieldDescriptorProto_TYPE_STRING:
		t = gopoet.StringType
	case descriptorpb.FieldDescriptorProto_TYPE_BYTES:
		t = bytesType
	case descriptorpb.FieldDescriptorProto_TYPE_INT32,
		descriptorpb.FieldDescriptorProto_TYPE_SINT32,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED32:
		t = gopoet.Int32Type
	case descriptorpb.FieldDescriptorProto_TYPE_INT64,
		descriptorpb.FieldDescriptorProto_TYPE_SINT64,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED64:
		t = gopoet.Int64Type
	case descriptorpb.FieldDescriptorProto_TYPE_UINT32,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED32:
		t = gopoet.Uint32Type
	case descriptorpb.FieldDescriptorProto_TYPE_UINT64,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED64:
		t = gopoet.Uint64Type
	case descriptorpb.FieldDescriptorProto_TYPE_FLOAT:
		t = gopoet.Float32Type
	case descriptorpb.FieldDescriptorProto_TYPE_DOUBLE:
		t = gopoet.Float64Type
	case descriptorpb.FieldDescriptorProto_TYPE_GROUP,
		descriptorpb.FieldDescriptorProto_TYPE_MESSAGE:
		t = gopoet.PointerType(x.MessageType(v.Message()))
	case descriptorpb.FieldDescriptorProto_TYPE_ENUM:
		t = x.enumType(v.Enum())
	default:
		panic(fmt.Sprintf("unknown type: %v", v))
	}
	if v.IsList() {
		t = gopoet.SliceType(t)
	}
	if v.ParentFile().Syntax() != protoreflect.Proto3 && t.Kind() != gopoet.KindPtr && t.Kind() != gopoet.KindSlice {
		// for proto2, type is pointer or slice
		t = gopoet.PointerType(t)
	}
	return
}
func (x *goField) Name() string              { return x.name }
func (x *goField) OneOf() *protogen.Oneof    { return x.oneOf }
func (x *goField) Fields() []*protogen.Field { return x.fields }
func (x *goField) init() {
	if x.oneOf != nil {
		// https://github.com/protocolbuffers/protobuf-go/blob/fc9592f7ac4bade8f83e636263f8f07715c698d1/cmd/protoc-gen-go/internal_gengo/main.go#L810
		x.typeName = gopoet.NamedType(gopoet.NewPackage(string(x.oneOf.GoIdent.GoImportPath)).Symbol("is" + x.oneOf.GoIdent.GoName))
		for _, field := range x.fields {
			x.oneOfFields = append(x.oneOfFields, OneOfField{
				Field:  field,
				Type:   gopoet.NamedType(gopoet.NewPackage(string(field.GoIdent.GoImportPath)).Symbol(field.GoIdent.GoName)),
				Getter: gopoet.MethodType{Name: `Get` + field.GoName, Signature: gopoet.Signature{Results: []gopoet.ArgType{{Type: x.cache.fieldType(field.Desc)}}}},
			})
		}
	} else {
		x.typeName = x.cache.fieldType(x.fields[0].Desc)
	}
	x.getter = gopoet.MethodType{Name: `Get` + x.name, Signature: gopoet.Signature{Results: []gopoet.ArgType{{Type: x.typeName}}}}
}
func (x *goField) Type() gopoet.TypeName {
	x.once.Do(x.init)
	return x.typeName
}
func (x *goField) Getter() gopoet.MethodType {
	x.once.Do(x.init)
	return x.getter
}
func (x *goField) OneOfFields() []OneOfField {
	x.once.Do(x.init)
	return x.oneOfFields
}
